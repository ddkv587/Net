!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
DEF_DEFAULT_VALUE	XMLElement.cpp	5;"	d	file:
ENCODING_UTF16	XMLHelper.hpp	/^				ENCODING_UTF16,$/;"	e	enum:NET::XMLHelper::XMLEncoding
ENCODING_UTF8	XMLHelper.hpp	/^				ENCODING_UTF8,$/;"	e	enum:NET::XMLHelper::XMLEncoding
NET	XMLElement.cpp	/^namespace NET $/;"	n	file:
NET	XMLElement.hpp	/^namespace NET $/;"	n
NET	XMLHelper.cpp	/^namespace NET $/;"	n	file:
NET	XMLHelper.hpp	/^namespace NET$/;"	n
RAPIDXML_ALIGNMENT	rapidxml/rapidxml.hpp	131;"	d
RAPIDXML_DYNAMIC_POOL_SIZE	rapidxml/rapidxml.hpp	123;"	d
RAPIDXML_HPP_INCLUDED	rapidxml/rapidxml.hpp	2;"	d
RAPIDXML_ITERATORS_HPP_INCLUDED	rapidxml/rapidxml_iterators.hpp	2;"	d
RAPIDXML_PARSE_ERROR	rapidxml/rapidxml.hpp	2589;"	d
RAPIDXML_PARSE_ERROR	rapidxml/rapidxml.hpp	28;"	d
RAPIDXML_PRINT_HPP_INCLUDED	rapidxml/rapidxml_print.hpp	2;"	d
RAPIDXML_STATIC_POOL_SIZE	rapidxml/rapidxml.hpp	116;"	d
RAPIDXML_UTILS_HPP_INCLUDED	rapidxml/rapidxml_utils.hpp	2;"	d
VERSION_1_0	XMLHelper.hpp	/^				VERSION_1_0,$/;"	e	enum:NET::XMLHelper::XMLVersion
VERSION_2_0	XMLHelper.hpp	/^				VERSION_2_0$/;"	e	enum:NET::XMLHelper::XMLVersion
XMLElement	XMLElement.cpp	/^	XMLElement::XMLElement(xml_node<>* root)$/;"	f	class:NET::XMLElement
XMLElement	XMLElement.hpp	/^	class XMLElement$/;"	c	namespace:NET
XMLEncoding	XMLHelper.hpp	/^			enum XMLEncoding$/;"	g	class:NET::XMLHelper
XMLHelper	XMLHelper.cpp	/^	XMLHelper(XMLVersion version, XMLEncoding encoding)$/;"	f	namespace:NET
XMLHelper	XMLHelper.hpp	/^	class XMLHelper$/;"	c	namespace:NET
XMLVersion	XMLHelper.hpp	/^			enum XMLVersion$/;"	g	class:NET::XMLHelper
__XMLELEMENTHPP__	XMLElement.hpp	2;"	d
__XMLHELPERHPP__	XMLHelper.hpp	2;"	d
addElement	XMLElement.cpp	/^	XMLElement*	XMLElement::addElement(const STRING strName)$/;"	f	class:NET::XMLElement
addRootElement	XMLHelper.hpp	/^			void					addRootElement(XMLElement* pElement)	{ m_pRootElement = pElement; }$/;"	f	class:NET::XMLHelper
align	rapidxml/rapidxml.hpp	/^        char *align(char *ptr)$/;"	f	class:rapidxml::memory_pool
alloc_func	rapidxml/rapidxml.hpp	/^        typedef void *(alloc_func)(std::size_t);       \/\/ Type of user-defined function used to allocate memory$/;"	t	class:rapidxml::memory_pool
allocate_aligned	rapidxml/rapidxml.hpp	/^        void *allocate_aligned(std::size_t size)$/;"	f	class:rapidxml::memory_pool
allocate_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *allocate_attribute(const Ch *name = 0, const Ch *value = 0, $/;"	f	class:rapidxml::memory_pool
allocate_node	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *allocate_node(node_type type, $/;"	f	class:rapidxml::memory_pool
allocate_raw	rapidxml/rapidxml.hpp	/^        char *allocate_raw(std::size_t size)$/;"	f	class:rapidxml::memory_pool
allocate_string	rapidxml/rapidxml.hpp	/^        Ch *allocate_string(const Ch *source = 0, std::size_t size = 0)$/;"	f	class:rapidxml::memory_pool
append_attribute	rapidxml/rapidxml.hpp	/^        void append_attribute(xml_attribute<Ch> *attribute)$/;"	f	class:rapidxml::xml_node
append_node	rapidxml/rapidxml.hpp	/^        void append_node(xml_node<Ch> *child)$/;"	f	class:rapidxml::xml_node
attribute_iterator	rapidxml/rapidxml_iterators.hpp	/^        attribute_iterator()$/;"	f	class:rapidxml::attribute_iterator
attribute_iterator	rapidxml/rapidxml_iterators.hpp	/^        attribute_iterator(xml_node<Ch> *node)$/;"	f	class:rapidxml::attribute_iterator
attribute_iterator	rapidxml/rapidxml_iterators.hpp	/^    class attribute_iterator$/;"	c	namespace:rapidxml
attribute_name_pred	rapidxml/rapidxml.hpp	/^        struct attribute_name_pred$/;"	s	class:rapidxml::xml_document
attribute_value_pred	rapidxml/rapidxml.hpp	/^        struct attribute_value_pred$/;"	s	class:rapidxml::xml_document
attribute_value_pure_pred	rapidxml/rapidxml.hpp	/^        struct attribute_value_pure_pred$/;"	s	class:rapidxml::xml_document
checkString	XMLElement.cpp	/^	BOOLEAN XMLElement::checkString(const STRING& str)$/;"	f	class:NET::XMLElement
clear	rapidxml/rapidxml.hpp	/^        void clear()$/;"	f	class:rapidxml::memory_pool
clear	rapidxml/rapidxml.hpp	/^        void clear()$/;"	f	class:rapidxml::xml_document
clearAttributes	XMLElement.cpp	/^	void XMLElement::clearAttributes()$/;"	f	class:NET::XMLElement
clearElements	XMLElement.cpp	/^	BOOLEAN	XMLElement::clearElements()$/;"	f	class:NET::XMLElement
clone_node	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *clone_node(const xml_node<Ch> *source, xml_node<Ch> *result = 0)$/;"	f	class:rapidxml::memory_pool
compare	rapidxml/rapidxml.hpp	/^        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)$/;"	f	namespace:rapidxml::internal
copy_and_expand_chars	rapidxml/rapidxml_print.hpp	/^        inline OutIt copy_and_expand_chars(const Ch *begin, const Ch *end, Ch noexpand, OutIt out)$/;"	f	namespace:rapidxml::internal
copy_chars	rapidxml/rapidxml_print.hpp	/^        inline OutIt copy_chars(const Ch *begin, const Ch *end, OutIt out)$/;"	f	namespace:rapidxml::internal
count_attributes	rapidxml/rapidxml_utils.hpp	/^    inline std::size_t count_attributes(xml_node<Ch> *node)$/;"	f	namespace:rapidxml
count_children	rapidxml/rapidxml_utils.hpp	/^    inline std::size_t count_children(xml_node<Ch> *node)$/;"	f	namespace:rapidxml
create	XMLHelper.cpp	/^	void XMLHelper::create()$/;"	f	class:NET::XMLHelper
data	rapidxml/rapidxml_utils.hpp	/^        Ch *data()$/;"	f	class:rapidxml::file
data	rapidxml/rapidxml_utils.hpp	/^        const Ch *data() const$/;"	f	class:rapidxml::file
deleteAttribute	XMLElement.cpp	/^	void XMLElement::deleteAttribute(const STRING strName)$/;"	f	class:NET::XMLElement
deleteElement	XMLElement.cpp	/^	BOOLEAN	XMLElement::deleteElement(const STRING strName)$/;"	f	class:NET::XMLElement
deleteRootElement	XMLHelper.cpp	/^	void XMLHelper::deleteRootElement()$/;"	f	class:NET::XMLHelper
difference_type	rapidxml/rapidxml_iterators.hpp	/^        typedef std::ptrdiff_t difference_type;$/;"	t	class:rapidxml::attribute_iterator
difference_type	rapidxml/rapidxml_iterators.hpp	/^        typedef std::ptrdiff_t difference_type;$/;"	t	class:rapidxml::node_iterator
document	rapidxml/rapidxml.hpp	/^        xml_document<Ch> *document() const$/;"	f	class:rapidxml::xml_attribute
document	rapidxml/rapidxml.hpp	/^        xml_document<Ch> *document() const$/;"	f	class:rapidxml::xml_node
file	rapidxml/rapidxml_utils.hpp	/^        file(const char *filename)$/;"	f	class:rapidxml::file
file	rapidxml/rapidxml_utils.hpp	/^        file(std::basic_istream<Ch> &stream)$/;"	f	class:rapidxml::file
file	rapidxml/rapidxml_utils.hpp	/^    class file$/;"	c	namespace:rapidxml
fill_chars	rapidxml/rapidxml_print.hpp	/^        inline OutIt fill_chars(OutIt out, int n, Ch ch)$/;"	f	namespace:rapidxml::internal
find_char	rapidxml/rapidxml_print.hpp	/^        inline bool find_char(const Ch *begin, const Ch *end)$/;"	f	namespace:rapidxml::internal
first_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *first_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_node
first_node	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *first_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_node
free_func	rapidxml/rapidxml.hpp	/^        typedef void (free_func)(void *);              \/\/ Type of user-defined function used to free memory$/;"	t	class:rapidxml::memory_pool
getAttribute	XMLElement.cpp	/^	xml_attribute<>* XMLElement::getAttribute(const STRING& strName, BOOLEAN bAdd)$/;"	f	class:NET::XMLElement
getAttributeBOOLEAN	XMLElement.cpp	/^	BOOLEAN XMLElement::getAttributeBOOLEAN(const STRING& strName)$/;"	f	class:NET::XMLElement
getAttributeByIndex	XMLElement.cpp	/^	STRING	XMLElement::getAttributeByIndex(UINT uiIndex)$/;"	f	class:NET::XMLElement
getAttributeCount	XMLElement.cpp	/^	UINT XMLElement::getAttributeCount()$/;"	f	class:NET::XMLElement
getAttributeFLOAT	XMLElement.cpp	/^	FLOAT XMLElement::getAttributeFLOAT(const STRING& strName)$/;"	f	class:NET::XMLElement
getAttributeINT	XMLElement.cpp	/^	INT XMLElement::getAttributeINT(const STRING& strName)$/;"	f	class:NET::XMLElement
getAttributeLLONG	XMLElement.cpp	/^	LLONG XMLElement::getAttributeLLONG(const STRING& strName)$/;"	f	class:NET::XMLElement
getAttributeString	XMLElement.cpp	/^	STRING XMLElement::getAttributeString(const STRING& strName) $/;"	f	class:NET::XMLElement
getAttributeUINT	XMLElement.cpp	/^	UINT XMLElement::getAttributeUINT(const STRING& strName)$/;"	f	class:NET::XMLElement
getElement	XMLElement.cpp	/^	XMLElement*	XMLElement::getElement(const STRING strName)$/;"	f	class:NET::XMLElement
getElement	XMLElement.cpp	/^	xml_node<>*	XMLElement::getElement(const STRING& strName, BOOLEAN bAdd)$/;"	f	class:NET::XMLElement
getElementByIndex	XMLElement.cpp	/^	XMLElement*	XMLElement::getElementByIndex(UINT uiIndex)$/;"	f	class:NET::XMLElement
getElementsCount	XMLElement.cpp	/^	UINT XMLElement::getElementsCount()$/;"	f	class:NET::XMLElement
getName	XMLElement.hpp	/^			const STRING&			getName()							{ return m_strName }$/;"	f	class:NET::XMLElement
getRootElement	XMLHelper.hpp	/^			XMLElement*				getRootElement()						{ return m_pRootElement; }$/;"	f	class:NET::XMLHelper
getValue	XMLElement.hpp	/^			const STRING&			getValue()							{ return m_strValue; }$/;"	f	class:NET::XMLElement
getXMLNode	XMLElement.hpp	/^			xml_node<>*				getXMLNode() const 					{ return m_pXMLNode; }$/;"	f	class:NET::XMLElement
hasAttribute	XMLElement.cpp	/^	BOOLEAN XMLElement::hasAttribute(const STRING& strName)$/;"	f	class:NET::XMLElement
hasAttributes	XMLElement.cpp	/^	BOOLEAN	XMLElement::hasAttributes()$/;"	f	class:NET::XMLElement
hasElement	XMLElement.cpp	/^	BOOLEAN	XMLElement::hasElement(const STRING strName)$/;"	f	class:NET::XMLElement
hasElements	XMLElement.cpp	/^	BOOLEAN XMLElement::hasElements()$/;"	f	class:NET::XMLElement
hasRootElement	XMLHelper.hpp	/^			BOOLEAN					hasRootElement()						{ return m_pRootElement == NULL; }$/;"	f	class:NET::XMLHelper
header	rapidxml/rapidxml.hpp	/^        struct header$/;"	s	class:rapidxml::memory_pool
init	rapidxml/rapidxml.hpp	/^        void init()$/;"	f	class:rapidxml::memory_pool
insert_attribute	rapidxml/rapidxml.hpp	/^        void insert_attribute(xml_attribute<Ch> *where, xml_attribute<Ch> *attribute)$/;"	f	class:rapidxml::xml_node
insert_coded_character	rapidxml/rapidxml.hpp	/^        static void insert_coded_character(Ch *&text, unsigned long code)$/;"	f	class:rapidxml::xml_document
insert_node	rapidxml/rapidxml.hpp	/^        void insert_node(xml_node<Ch> *where, xml_node<Ch> *child)$/;"	f	class:rapidxml::xml_node
internal	rapidxml/rapidxml.hpp	/^    namespace internal$/;"	n	namespace:rapidxml
internal	rapidxml/rapidxml_print.hpp	/^    namespace internal$/;"	n	namespace:rapidxml
iterator_category	rapidxml/rapidxml_iterators.hpp	/^        typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:rapidxml::attribute_iterator
iterator_category	rapidxml/rapidxml_iterators.hpp	/^        typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:rapidxml::node_iterator
last_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *last_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_node
last_node	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *last_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_node
lookup_attribute_data_1	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_attribute_data_1[256];        \/\/ Attribute data table with single quote$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_attribute_data_1	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_attribute_data_1_pure	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_attribute_data_1_pure[256];   \/\/ Attribute data table with single quote$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_attribute_data_1_pure	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1_pure[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_attribute_data_2	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_attribute_data_2[256];        \/\/ Attribute data table with double quotes$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_attribute_data_2	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_attribute_data_2_pure	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_attribute_data_2_pure[256];   \/\/ Attribute data table with double quotes$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_attribute_data_2_pure	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2_pure[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_attribute_name	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_attribute_name[256];          \/\/ Attribute name table$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_attribute_name	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_attribute_name[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_digits	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_digits[256];                  \/\/ Digits$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_digits	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_digits[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_node_name	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_node_name[256];               \/\/ Node name table$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_node_name	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_node_name[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_tables	rapidxml/rapidxml.hpp	/^        struct lookup_tables$/;"	s	namespace:rapidxml::internal
lookup_text	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_text[256];                    \/\/ Text table$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_text	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_text[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_text_pure_no_ws	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_text_pure_no_ws[256];         \/\/ Text table$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_text_pure_no_ws	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_text_pure_no_ws[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_text_pure_with_ws	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_text_pure_with_ws[256];       \/\/ Text table$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_text_pure_with_ws	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_text_pure_with_ws[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_upcase	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_upcase[256];                  \/\/ To uppercase conversion table for ASCII characters$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_upcase	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_upcase[256] = $/;"	m	class:rapidxml::internal::lookup_tables
lookup_whitespace	rapidxml/rapidxml.hpp	/^            static const unsigned char lookup_whitespace[256];              \/\/ Whitespace table$/;"	m	struct:rapidxml::internal::lookup_tables
lookup_whitespace	rapidxml/rapidxml.hpp	/^        const unsigned char lookup_tables<Dummy>::lookup_whitespace[256] = $/;"	m	class:rapidxml::internal::lookup_tables
m_alloc_func	rapidxml/rapidxml.hpp	/^        alloc_func *m_alloc_func;                           \/\/ Allocator function, or 0 if default is to be used$/;"	m	class:rapidxml::memory_pool
m_attribute	rapidxml/rapidxml_iterators.hpp	/^        xml_attribute<Ch> *m_attribute;$/;"	m	class:rapidxml::attribute_iterator
m_begin	rapidxml/rapidxml.hpp	/^        char *m_begin;                                      \/\/ Start of raw memory making up current pool$/;"	m	class:rapidxml::memory_pool
m_data	rapidxml/rapidxml_utils.hpp	/^        std::vector<Ch> m_data;   \/\/ File data$/;"	m	class:rapidxml::file
m_eEncoding	XMLHelper.hpp	/^			XMLEncoding				m_eEncoding;$/;"	m	class:NET::XMLHelper
m_eVersion	XMLHelper.hpp	/^			XMLVersion				m_eVersion;$/;"	m	class:NET::XMLHelper
m_end	rapidxml/rapidxml.hpp	/^        char *m_end;                                        \/\/ One past last available byte in current pool$/;"	m	class:rapidxml::memory_pool
m_first_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *m_first_attribute;   \/\/ Pointer to first attribute of node, or 0 if none; always valid$/;"	m	class:rapidxml::xml_node
m_first_node	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *m_first_node;             \/\/ Pointer to first child node, or 0 if none; always valid$/;"	m	class:rapidxml::xml_node
m_free_func	rapidxml/rapidxml.hpp	/^        free_func *m_free_func;                             \/\/ Free function, or 0 if default is to be used$/;"	m	class:rapidxml::memory_pool
m_last_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *m_last_attribute;    \/\/ Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero$/;"	m	class:rapidxml::xml_node
m_last_node	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *m_last_node;              \/\/ Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero$/;"	m	class:rapidxml::xml_node
m_name	rapidxml/rapidxml.hpp	/^        Ch *m_name;                         \/\/ Name of node, or 0 if no name$/;"	m	class:rapidxml::xml_base
m_name_size	rapidxml/rapidxml.hpp	/^        std::size_t m_name_size;            \/\/ Length of node name, or undefined of no name$/;"	m	class:rapidxml::xml_base
m_next_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *m_next_attribute;        \/\/ Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero$/;"	m	class:rapidxml::xml_attribute
m_next_sibling	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *m_next_sibling;           \/\/ Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero$/;"	m	class:rapidxml::xml_node
m_node	rapidxml/rapidxml_iterators.hpp	/^        xml_node<Ch> *m_node;$/;"	m	class:rapidxml::node_iterator
m_pRootElement	XMLHelper.hpp	/^			XMLElement*				m_pRootElement;$/;"	m	class:NET::XMLHelper
m_pXMLNode	XMLElement.hpp	/^			xml_node<>*				m_pXMLNode;$/;"	m	class:NET::XMLElement
m_pXmlDoc	XMLHelper.hpp	/^			xml_document<>*			m_pXmlDoc;$/;"	m	class:NET::XMLHelper
m_parent	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *m_parent;             \/\/ Pointer to parent node, or 0 if none$/;"	m	class:rapidxml::xml_base
m_prev_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *m_prev_attribute;        \/\/ Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero$/;"	m	class:rapidxml::xml_attribute
m_prev_sibling	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *m_prev_sibling;           \/\/ Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero$/;"	m	class:rapidxml::xml_node
m_ptr	rapidxml/rapidxml.hpp	/^        char *m_ptr;                                        \/\/ First free byte in current pool$/;"	m	class:rapidxml::memory_pool
m_static_memory	rapidxml/rapidxml.hpp	/^        char m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    \/\/ Static raw memory$/;"	m	class:rapidxml::memory_pool
m_strName	XMLElement.hpp	/^			STRING					m_strName;$/;"	m	class:NET::XMLElement
m_strValue	XMLElement.hpp	/^			STRING					m_strValue;$/;"	m	class:NET::XMLElement
m_type	rapidxml/rapidxml.hpp	/^        node_type m_type;                       \/\/ Type of node; always valid$/;"	m	class:rapidxml::xml_node
m_uiAttributeSize	XMLElement.hpp	/^			UINT					m_uiAttributeSize;$/;"	m	class:NET::XMLElement
m_uiElementSize	XMLElement.hpp	/^			UINT					m_uiElementSize;$/;"	m	class:NET::XMLElement
m_value	rapidxml/rapidxml.hpp	/^        Ch *m_value;                        \/\/ Value of node, or 0 if no value$/;"	m	class:rapidxml::xml_base
m_value_size	rapidxml/rapidxml.hpp	/^        std::size_t m_value_size;           \/\/ Length of node value, or undefined if no value$/;"	m	class:rapidxml::xml_base
measure	rapidxml/rapidxml.hpp	/^        inline std::size_t measure(const Ch *p)$/;"	f	namespace:rapidxml::internal
memory_pool	rapidxml/rapidxml.hpp	/^        memory_pool()$/;"	f	class:rapidxml::memory_pool
memory_pool	rapidxml/rapidxml.hpp	/^    class memory_pool$/;"	c	namespace:rapidxml
name	rapidxml/rapidxml.hpp	/^        Ch *name() const$/;"	f	class:rapidxml::xml_base
name	rapidxml/rapidxml.hpp	/^        void name(const Ch *name)$/;"	f	class:rapidxml::xml_base
name	rapidxml/rapidxml.hpp	/^        void name(const Ch *name, std::size_t size)$/;"	f	class:rapidxml::xml_base
name_size	rapidxml/rapidxml.hpp	/^        std::size_t name_size() const$/;"	f	class:rapidxml::xml_base
next_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *next_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_attribute
next_sibling	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *next_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_node
node_cdata	rapidxml/rapidxml.hpp	/^        node_cdata,         \/\/!< A CDATA node. Name is empty. Value contains data text.$/;"	e	enum:rapidxml::node_type
node_comment	rapidxml/rapidxml.hpp	/^        node_comment,       \/\/!< A comment node. Name is empty. Value contains comment text.$/;"	e	enum:rapidxml::node_type
node_data	rapidxml/rapidxml.hpp	/^        node_data,          \/\/!< A data node. Name is empty. Value contains data text.$/;"	e	enum:rapidxml::node_type
node_declaration	rapidxml/rapidxml.hpp	/^        node_declaration,   \/\/!< A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.$/;"	e	enum:rapidxml::node_type
node_doctype	rapidxml/rapidxml.hpp	/^        node_doctype,       \/\/!< A DOCTYPE node. Name is empty. Value contains DOCTYPE text.$/;"	e	enum:rapidxml::node_type
node_document	rapidxml/rapidxml.hpp	/^        node_document,      \/\/!< A document node. Name and value are empty.$/;"	e	enum:rapidxml::node_type
node_element	rapidxml/rapidxml.hpp	/^        node_element,       \/\/!< An element node. Name contains element name. Value contains text of first data node.$/;"	e	enum:rapidxml::node_type
node_iterator	rapidxml/rapidxml_iterators.hpp	/^        node_iterator()$/;"	f	class:rapidxml::node_iterator
node_iterator	rapidxml/rapidxml_iterators.hpp	/^        node_iterator(xml_node<Ch> *node)$/;"	f	class:rapidxml::node_iterator
node_iterator	rapidxml/rapidxml_iterators.hpp	/^    class node_iterator$/;"	c	namespace:rapidxml
node_name_pred	rapidxml/rapidxml.hpp	/^        struct node_name_pred$/;"	s	class:rapidxml::xml_document
node_pi	rapidxml/rapidxml.hpp	/^        node_pi             \/\/!< A PI node. Name contains target. Value contains instructions.$/;"	e	enum:rapidxml::node_type
node_type	rapidxml/rapidxml.hpp	/^    enum node_type$/;"	g	namespace:rapidxml
nullstr	rapidxml/rapidxml.hpp	/^        static Ch *nullstr()$/;"	f	class:rapidxml::xml_base
operator !=	rapidxml/rapidxml_iterators.hpp	/^        bool operator !=(const attribute_iterator<Ch> &rhs)$/;"	f	class:rapidxml::attribute_iterator
operator !=	rapidxml/rapidxml_iterators.hpp	/^        bool operator !=(const node_iterator<Ch> &rhs)$/;"	f	class:rapidxml::node_iterator
operator *	rapidxml/rapidxml_iterators.hpp	/^        reference operator *() const$/;"	f	class:rapidxml::attribute_iterator
operator *	rapidxml/rapidxml_iterators.hpp	/^        reference operator *() const$/;"	f	class:rapidxml::node_iterator
operator ++	rapidxml/rapidxml_iterators.hpp	/^        attribute_iterator operator++(int)$/;"	f	class:rapidxml::attribute_iterator
operator ++	rapidxml/rapidxml_iterators.hpp	/^        attribute_iterator& operator++()$/;"	f	class:rapidxml::attribute_iterator
operator ++	rapidxml/rapidxml_iterators.hpp	/^        node_iterator operator++(int)$/;"	f	class:rapidxml::node_iterator
operator ++	rapidxml/rapidxml_iterators.hpp	/^        node_iterator& operator++()$/;"	f	class:rapidxml::node_iterator
operator --	rapidxml/rapidxml_iterators.hpp	/^        attribute_iterator operator--(int)$/;"	f	class:rapidxml::attribute_iterator
operator --	rapidxml/rapidxml_iterators.hpp	/^        attribute_iterator& operator--()$/;"	f	class:rapidxml::attribute_iterator
operator --	rapidxml/rapidxml_iterators.hpp	/^        node_iterator operator--(int)$/;"	f	class:rapidxml::node_iterator
operator --	rapidxml/rapidxml_iterators.hpp	/^        node_iterator& operator--()$/;"	f	class:rapidxml::node_iterator
operator ->	rapidxml/rapidxml_iterators.hpp	/^        pointer operator->() const$/;"	f	class:rapidxml::attribute_iterator
operator ->	rapidxml/rapidxml_iterators.hpp	/^        pointer operator->() const$/;"	f	class:rapidxml::node_iterator
operator <<	rapidxml/rapidxml_print.hpp	/^    inline std::basic_ostream<Ch> &operator <<(std::basic_ostream<Ch> &out, const xml_node<Ch> &node)$/;"	f	namespace:rapidxml
operator ==	rapidxml/rapidxml_iterators.hpp	/^        bool operator ==(const attribute_iterator<Ch> &rhs)$/;"	f	class:rapidxml::attribute_iterator
operator ==	rapidxml/rapidxml_iterators.hpp	/^        bool operator ==(const node_iterator<Ch> &rhs)$/;"	f	class:rapidxml::node_iterator
parent	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parent() const$/;"	f	class:rapidxml::xml_base
parse	XMLHelper.cpp	/^	BOOLEAN XMLHelper::parse(const CHAR* strContent)$/;"	f	class:NET::XMLHelper
parse	rapidxml/rapidxml.hpp	/^        void parse(Ch *text)$/;"	f	class:rapidxml::xml_document
parseFrom	XMLHelper.cpp	/^	BOOLEAN	XMLHelper::parseFrom(const CHAR* strPath)$/;"	f	class:NET::XMLHelper
parse_and_append_data	rapidxml/rapidxml.hpp	/^        Ch parse_and_append_data(xml_node<Ch> *node, Ch *&text, Ch *contents_start)$/;"	f	class:rapidxml::xml_document
parse_bom	rapidxml/rapidxml.hpp	/^        void parse_bom(Ch *&text)$/;"	f	class:rapidxml::xml_document
parse_cdata	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parse_cdata(Ch *&text)$/;"	f	class:rapidxml::xml_document
parse_comment	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parse_comment(Ch *&text)$/;"	f	class:rapidxml::xml_document
parse_comment_nodes	rapidxml/rapidxml.hpp	/^    const int parse_comment_nodes = 0x40;$/;"	m	namespace:rapidxml
parse_declaration_node	rapidxml/rapidxml.hpp	/^    const int parse_declaration_node = 0x20;$/;"	m	namespace:rapidxml
parse_default	rapidxml/rapidxml.hpp	/^    const int parse_default = 0;$/;"	m	namespace:rapidxml
parse_doctype	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parse_doctype(Ch *&text)$/;"	f	class:rapidxml::xml_document
parse_doctype_node	rapidxml/rapidxml.hpp	/^    const int parse_doctype_node = 0x80;$/;"	m	namespace:rapidxml
parse_element	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parse_element(Ch *&text)$/;"	f	class:rapidxml::xml_document
parse_fastest	rapidxml/rapidxml.hpp	/^    const int parse_fastest = parse_non_destructive | parse_no_data_nodes;$/;"	m	namespace:rapidxml
parse_full	rapidxml/rapidxml.hpp	/^    const int parse_full = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;$/;"	m	namespace:rapidxml
parse_no_data_nodes	rapidxml/rapidxml.hpp	/^    const int parse_no_data_nodes = 0x1;            $/;"	m	namespace:rapidxml
parse_no_element_values	rapidxml/rapidxml.hpp	/^    const int parse_no_element_values = 0x2;$/;"	m	namespace:rapidxml
parse_no_entity_translation	rapidxml/rapidxml.hpp	/^    const int parse_no_entity_translation = 0x8;$/;"	m	namespace:rapidxml
parse_no_string_terminators	rapidxml/rapidxml.hpp	/^    const int parse_no_string_terminators = 0x4;$/;"	m	namespace:rapidxml
parse_no_utf8	rapidxml/rapidxml.hpp	/^    const int parse_no_utf8 = 0x10;$/;"	m	namespace:rapidxml
parse_node	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parse_node(Ch *&text)$/;"	f	class:rapidxml::xml_document
parse_node_attributes	rapidxml/rapidxml.hpp	/^        void parse_node_attributes(Ch *&text, xml_node<Ch> *node)$/;"	f	class:rapidxml::xml_document
parse_node_contents	rapidxml/rapidxml.hpp	/^        void parse_node_contents(Ch *&text, xml_node<Ch> *node)$/;"	f	class:rapidxml::xml_document
parse_non_destructive	rapidxml/rapidxml.hpp	/^    const int parse_non_destructive = parse_no_string_terminators | parse_no_entity_translation;$/;"	m	namespace:rapidxml
parse_normalize_whitespace	rapidxml/rapidxml.hpp	/^    const int parse_normalize_whitespace = 0x800;$/;"	m	namespace:rapidxml
parse_pi	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parse_pi(Ch *&text)$/;"	f	class:rapidxml::xml_document
parse_pi_nodes	rapidxml/rapidxml.hpp	/^    const int parse_pi_nodes = 0x100;$/;"	m	namespace:rapidxml
parse_trim_whitespace	rapidxml/rapidxml.hpp	/^    const int parse_trim_whitespace = 0x400;$/;"	m	namespace:rapidxml
parse_validate_closing_tags	rapidxml/rapidxml.hpp	/^    const int parse_validate_closing_tags = 0x200;$/;"	m	namespace:rapidxml
parse_xml_declaration	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *parse_xml_declaration(Ch *&text)$/;"	f	class:rapidxml::xml_document
pointer	rapidxml/rapidxml_iterators.hpp	/^        typedef typename xml_attribute<Ch> *pointer;$/;"	t	class:rapidxml::attribute_iterator
pointer	rapidxml/rapidxml_iterators.hpp	/^        typedef typename xml_node<Ch> *pointer;$/;"	t	class:rapidxml::node_iterator
prepend_attribute	rapidxml/rapidxml.hpp	/^        void prepend_attribute(xml_attribute<Ch> *attribute)$/;"	f	class:rapidxml::xml_node
prepend_node	rapidxml/rapidxml.hpp	/^        void prepend_node(xml_node<Ch> *child)$/;"	f	class:rapidxml::xml_node
previous_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute<Ch> *previous_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_attribute
previous_begin	rapidxml/rapidxml.hpp	/^            char *previous_begin;$/;"	m	struct:rapidxml::memory_pool::header
previous_sibling	rapidxml/rapidxml.hpp	/^        xml_node<Ch> *previous_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const$/;"	f	class:rapidxml::xml_node
print	rapidxml/rapidxml_print.hpp	/^    inline OutIt print(OutIt out, const xml_node<Ch> &node, int flags = 0)$/;"	f	namespace:rapidxml
print	rapidxml/rapidxml_print.hpp	/^    inline std::basic_ostream<Ch> &print(std::basic_ostream<Ch> &out, const xml_node<Ch> &node, int flags = 0)$/;"	f	namespace:rapidxml
print_attributes	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_attributes(OutIt out, const xml_node<Ch> *node, int flags)$/;"	f	namespace:rapidxml::internal
print_cdata_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_children	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_comment_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_data_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_declaration_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_doctype_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_element_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_no_indenting	rapidxml/rapidxml_print.hpp	/^    const int print_no_indenting = 0x1;   \/\/!< Printer flag instructing the printer to suppress indenting of XML. See print() function.$/;"	m	namespace:rapidxml
print_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
print_pi_node	rapidxml/rapidxml_print.hpp	/^        inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)$/;"	f	namespace:rapidxml::internal
rapidxml	rapidxml/rapidxml.hpp	/^namespace rapidxml$/;"	n
rapidxml	rapidxml/rapidxml_iterators.hpp	/^namespace rapidxml$/;"	n
rapidxml	rapidxml/rapidxml_print.hpp	/^namespace rapidxml$/;"	n
rapidxml	rapidxml/rapidxml_utils.hpp	/^namespace rapidxml$/;"	n
reference	rapidxml/rapidxml_iterators.hpp	/^        typedef typename xml_attribute<Ch> &reference;$/;"	t	class:rapidxml::attribute_iterator
reference	rapidxml/rapidxml_iterators.hpp	/^        typedef typename xml_node<Ch> &reference;$/;"	t	class:rapidxml::node_iterator
remove_all_attributes	rapidxml/rapidxml.hpp	/^        void remove_all_attributes()$/;"	f	class:rapidxml::xml_node
remove_all_nodes	rapidxml/rapidxml.hpp	/^        void remove_all_nodes()$/;"	f	class:rapidxml::xml_node
remove_attribute	rapidxml/rapidxml.hpp	/^        void remove_attribute(xml_attribute<Ch> *where)$/;"	f	class:rapidxml::xml_node
remove_first_attribute	rapidxml/rapidxml.hpp	/^        void remove_first_attribute()$/;"	f	class:rapidxml::xml_node
remove_first_node	rapidxml/rapidxml.hpp	/^        void remove_first_node()$/;"	f	class:rapidxml::xml_node
remove_last_attribute	rapidxml/rapidxml.hpp	/^        void remove_last_attribute()$/;"	f	class:rapidxml::xml_node
remove_last_node	rapidxml/rapidxml.hpp	/^        void remove_last_node()$/;"	f	class:rapidxml::xml_node
remove_node	rapidxml/rapidxml.hpp	/^        void remove_node(xml_node<Ch> *where)$/;"	f	class:rapidxml::xml_node
saveTo	XMLHelper.cpp	/^	BOOLEAN XMLHelper::saveTo(const CHAR* strPath)$/;"	f	class:NET::XMLHelper
setAttribute	XMLElement.cpp	/^	void XMLElement::setAttribute(const STRING& strName, BOOLEAN bValue)$/;"	f	class:NET::XMLElement
setAttribute	XMLElement.cpp	/^	void XMLElement::setAttribute(const STRING& strName, FLOAT fValue)$/;"	f	class:NET::XMLElement
setAttribute	XMLElement.cpp	/^	void XMLElement::setAttribute(const STRING& strName, INT iValue)$/;"	f	class:NET::XMLElement
setAttribute	XMLElement.cpp	/^	void XMLElement::setAttribute(const STRING& strName, LLONG lValue)$/;"	f	class:NET::XMLElement
setAttribute	XMLElement.cpp	/^	void XMLElement::setAttribute(const STRING& strName, UINT uiValue)$/;"	f	class:NET::XMLElement
setAttribute	XMLElement.cpp	/^	void XMLElement::setAttribute(const STRING& strName, const STRING& strValue)$/;"	f	class:NET::XMLElement
setName	XMLElement.cpp	/^	void XMLElement::setName(const STRING& strName)		$/;"	f	class:NET::XMLElement
setValue	XMLElement.cpp	/^	void XMLElement::setValue(const STRING& strValue)		$/;"	f	class:NET::XMLElement
setXMLNode	XMLElement.hpp	/^			void					setXMLNode(xml_node<>* pNode)		{ m_pXMLNode = pNode; }$/;"	f	class:NET::XMLElement
set_allocator	rapidxml/rapidxml.hpp	/^        void set_allocator(alloc_func *af, free_func *ff)$/;"	f	class:rapidxml::memory_pool
size	rapidxml/rapidxml_utils.hpp	/^        std::size_t size() const$/;"	f	class:rapidxml::file
skip	rapidxml/rapidxml.hpp	/^        static void skip(Ch *&text)$/;"	f	class:rapidxml::xml_document
skip_and_expand_character_refs	rapidxml/rapidxml.hpp	/^        static Ch *skip_and_expand_character_refs(Ch *&text)$/;"	f	class:rapidxml::xml_document
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::attribute_name_pred
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::attribute_value_pred
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::attribute_value_pure_pred
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::node_name_pred
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::text_pred
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::text_pure_no_ws_pred
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::text_pure_with_ws_pred
test	rapidxml/rapidxml.hpp	/^            static unsigned char test(Ch ch)$/;"	f	struct:rapidxml::xml_document::whitespace_pred
text_pred	rapidxml/rapidxml.hpp	/^        struct text_pred$/;"	s	class:rapidxml::xml_document
text_pure_no_ws_pred	rapidxml/rapidxml.hpp	/^        struct text_pure_no_ws_pred$/;"	s	class:rapidxml::xml_document
text_pure_with_ws_pred	rapidxml/rapidxml.hpp	/^        struct text_pure_with_ws_pred$/;"	s	class:rapidxml::xml_document
type	rapidxml/rapidxml.hpp	/^        node_type type() const$/;"	f	class:rapidxml::xml_node
type	rapidxml/rapidxml.hpp	/^        void type(node_type type)$/;"	f	class:rapidxml::xml_node
value	rapidxml/rapidxml.hpp	/^        Ch *value() const$/;"	f	class:rapidxml::xml_base
value	rapidxml/rapidxml.hpp	/^        void value(const Ch *value)$/;"	f	class:rapidxml::xml_base
value	rapidxml/rapidxml.hpp	/^        void value(const Ch *value, std::size_t size)$/;"	f	class:rapidxml::xml_base
value_size	rapidxml/rapidxml.hpp	/^        std::size_t value_size() const$/;"	f	class:rapidxml::xml_base
value_type	rapidxml/rapidxml_iterators.hpp	/^        typedef typename xml_attribute<Ch> value_type;$/;"	t	class:rapidxml::attribute_iterator
value_type	rapidxml/rapidxml_iterators.hpp	/^        typedef typename xml_node<Ch> value_type;$/;"	t	class:rapidxml::node_iterator
whitespace_pred	rapidxml/rapidxml.hpp	/^        struct whitespace_pred$/;"	s	class:rapidxml::xml_document
xml_attribute	rapidxml/rapidxml.hpp	/^        xml_attribute()$/;"	f	class:rapidxml::xml_attribute
xml_attribute	rapidxml/rapidxml.hpp	/^    class xml_attribute: public xml_base<Ch>$/;"	c	namespace:rapidxml
xml_base	rapidxml/rapidxml.hpp	/^        xml_base()$/;"	f	class:rapidxml::xml_base
xml_base	rapidxml/rapidxml.hpp	/^    class xml_base$/;"	c	namespace:rapidxml
xml_document	rapidxml/rapidxml.hpp	/^        xml_document()$/;"	f	class:rapidxml::xml_document
xml_document	rapidxml/rapidxml.hpp	/^    class xml_document: public xml_node<Ch>, public memory_pool<Ch>$/;"	c	namespace:rapidxml
xml_node	rapidxml/rapidxml.hpp	/^        xml_node(node_type type)$/;"	f	class:rapidxml::xml_node
xml_node	rapidxml/rapidxml.hpp	/^    class xml_node: public xml_base<Ch>$/;"	c	namespace:rapidxml
~XMLElement	XMLElement.cpp	/^	XMLElement::~XMLElement()$/;"	f	class:NET::XMLElement
~XMLHelper	XMLHelper.cpp	/^	XMLHelper::~XMLHelper()$/;"	f	class:NET::XMLHelper
~memory_pool	rapidxml/rapidxml.hpp	/^        ~memory_pool()$/;"	f	class:rapidxml::memory_pool
