						if ( ret == -1 ) {
							close(fired->fd);
							delEvent(fired->fd, NET_READABLE);
							continue;
						} else

							if ( size != header->length ) continue; 

							switch( header->protocol ) {
							case EP_ECHO:
								printf("recv echo msg: %s\n", buff);
								size = send(e->ident, buff, size, 0);
								printf("send size: %d\n", size);
								break;
							case EP_PING:
								{
									printf("recv ping msg: %s\n", buff + sizeof(PING_MANAGER));
									PING_MANAGER* ping_header = (PING_MANAGER*)buff;
									if ( ping_header->current < ping_header->deadLimit ) {
										printf("recv ping current: %d\n", ping_header->current);
										ping_header->current += 1;

										char* sendBuff = (char *)malloc(size + sizeof(HEADER_MANAGER));

										memcpy(sendBuff, header, sizeof(HEADER_MANAGER));
										memcpy(sendBuff+sizeof(HEADER_MANAGER), buff, size);

										size = send(e->ident, sendBuff, size + sizeof(HEADER_MANAGER), 0);
										printf("send size: %d\n", size);

										free(sendBuff);
									}
								}
								break;
							case EP_TIME:
								break;
							case EP_HEART:
								break;
							default:break;
							}
						}
						file->dataSzie = 0;
						delete file->data;
					}
